// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Deque from "../src/impl/Deque.mjs";
import * as Belt_Array from "@rescript/std/lib/es6/belt_Array.js";
import * as Caml_int32 from "@rescript/std/lib/es6/caml_int32.js";
import * as Belt_MapInt from "@rescript/std/lib/es6/belt_MapInt.js";
import * as Caml_option from "@rescript/std/lib/es6/caml_option.js";
import * as Belt_SortArrayInt from "@rescript/std/lib/es6/belt_SortArrayInt.js";

function make(param) {
  return Deque.pushFront(Deque.empty, 0);
}

function ccw(circle) {
  var v = Deque.peekBack(circle);
  if (v !== undefined) {
    return Deque.pushFront(Deque.popBack(circle), Caml_option.valFromOption(v));
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "deque_test.res",
          11,
          14
        ],
        Error: new Error()
      };
}

function cw(circle) {
  var v = Deque.peekFront(circle);
  if (v !== undefined) {
    return Deque.pushBack(Deque.popFront(circle), Caml_option.valFromOption(v));
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "deque_test.res",
          17,
          14
        ],
        Error: new Error()
      };
}

function peek(circle) {
  var v = Deque.peekBack(circle);
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "deque_test.res",
          25,
          14
        ],
        Error: new Error()
      };
}

var Circle = {
  make: make,
  ccw: ccw,
  cw: cw,
  push: Deque.pushBack,
  pop: Deque.popBack,
  peek: peek
};

function place(circle, nextNum) {
  if (nextNum % 23 !== 0) {
    return [
            Deque.pushBack(cw(circle), nextNum),
            0
          ];
  }
  var circle$1 = ccw(ccw(ccw(ccw(ccw(ccw(ccw(circle)))))));
  var scoreAt = peek(circle$1);
  return [
          cw(Deque.popBack(circle$1)),
          scoreAt + nextNum | 0
        ];
}

function play(circle, numPlayers, lastMarble) {
  var _circle = circle;
  var _marble = 1;
  var _scoreMap;
  while(true) {
    var scoreMap = _scoreMap;
    var marble = _marble;
    var circle$1 = _circle;
    if (marble > lastMarble) {
      var scores = Belt_SortArrayInt.stableSort(Belt_MapInt.keysToArray(scoreMap));
      return Belt_Array.getExn(scores, scores.length - 1 | 0);
    }
    var match = place(circle$1, marble);
    var score = match[1];
    var player = Caml_int32.mod_(marble, numPlayers);
    var scoreMap$1 = Belt_MapInt.update(scoreMap, player, (function(score){
        return function (v) {
          return v !== undefined ? v + score | 0 : score;
        }
        }(score)));
    _scoreMap = scoreMap$1;
    _marble = marble + 1 | 0;
    _circle = match[0];
    continue ;
  };
}

console.log(play(Deque.pushFront(Deque.empty, 0), 459, 71790));

export {
  Circle ,
  place ,
  play ,
}
/*  Not a pure module */
