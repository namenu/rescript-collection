// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Bit from "./Bit.js";
import * as JsArray from "./JsArray.js";
import * as Caml_obj from "@rescript/std/lib/es6/caml_obj.js";
import * as Caml_option from "@rescript/std/lib/es6/caml_option.js";

function empty(param) {
  return {
          TAG: /* ArrayMap */0,
          _0: []
        };
}

function hashCollision_findIndex(param, key) {
  return param.entries.findIndex(function (param) {
              return Caml_obj.caml_equal(param[0], key);
            });
}

function assoc(self, key, value) {
  var idx = hashCollision_findIndex(self, key);
  if (idx === -1) {
    return {
            hash: self.hash,
            entries: JsArray.cloneAndAdd(self.entries, [
                  key,
                  value
                ])
          };
  } else {
    return self;
  }
}

function dissoc(self, key) {
  var entries = self.entries;
  var idx = hashCollision_findIndex(self, key);
  if (idx === -1) {
    return self;
  } else if (entries.length === 1) {
    return ;
  } else {
    return {
            hash: self.hash,
            entries: JsArray.cloneWithout(entries, idx)
          };
  }
}

function arrayMap_findIndex(entries, key) {
  var len = entries.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= len) {
      return -1;
    }
    if (Caml_obj.caml_equal(entries[i][0], key)) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function arrayMap_assocAt(entries, idx, key, value) {
  if (idx !== -1) {
    if (entries[idx][1] === value) {
      return entries;
    } else {
      return JsArray.cloneAndSet(entries, idx, [
                  key,
                  value
                ]);
    }
  } else {
    return JsArray.cloneAndAdd(entries, [
                key,
                value
              ]);
  }
}

function arrayMap_dissoc(entries, key) {
  var idx = arrayMap_findIndex(entries, key);
  if (idx === -1) {
    return entries;
  } else {
    return JsArray.cloneWithoutUnstable(entries, idx);
  }
}

function mask(hash, shift) {
  return (hash >>> shift) & 31;
}

function bitpos(hash, shift) {
  return (1 << mask(hash, shift));
}

function indexOfBit(bitmap, bit) {
  var v = bitmap & (bit - 1 | 0);
  var v$1 = v - ((v >>> 1) & 1431655765) | 0;
  var v$2 = (v$1 & 858993459) + ((v$1 >>> 2) & 858993459) | 0;
  var v$3 = v$2 + (v$2 >>> 4) & 252645135;
  var v$4 = v$3 + (v$3 >>> 8) | 0;
  var v$5 = v$4 + (v$4 >>> 16) | 0;
  return v$5 & 127;
}

function find(node, shift, hash, key) {
  switch (node.TAG | 0) {
    case /* ArrayMap */0 :
        var entries = node._0;
        var idx = arrayMap_findIndex(entries, key);
        if (idx === -1) {
          return ;
        } else {
          return Caml_option.some(entries[idx][1]);
        }
    case /* BitmapIndexed */1 :
        var param = node._0;
        var bitmap = param.bitmap;
        var bit = bitpos(hash, shift);
        var match = bitmap & bit;
        if (match === 0) {
          return ;
        }
        var idx$1 = indexOfBit(bitmap, bit);
        var child = param.data[idx$1];
        return find(child, shift, hash, key);
    case /* HashArrayMap */2 :
        var param$1 = node._0;
        var idx$2 = mask(hash, shift);
        var node$1 = param$1.nodes[idx$2];
        if (node$1 !== undefined) {
          return find(node$1, shift, hash, key);
        } else {
          return ;
        }
    case /* MapEntry */3 :
        var match$1 = node._0;
        if (Caml_obj.caml_equal(match$1[0], key)) {
          return Caml_option.some(match$1[1]);
        } else {
          return ;
        }
    case /* HashCollision */4 :
        var param$2 = node._0;
        var match$2 = param$2.entries.find(function (param) {
              return Caml_obj.caml_equal(param[0], key);
            });
        if (match$2 !== undefined) {
          return Caml_option.some(match$2[1]);
        } else {
          return ;
        }
    
  }
}

function bitmapIndexed_assocInternal(self, shift, hasher, hash, key, value) {
  var data = self.data;
  var bitmap = self.bitmap;
  var bit = bitpos(hash, shift);
  var idx = indexOfBit(bitmap, bit);
  var match = bitmap & bit;
  if (match === 0) {
    return {
            bitmap: bitmap | bit,
            data: JsArray.cloneAndInsert(data, idx, {
                  TAG: /* MapEntry */3,
                  _0: [
                    key,
                    value
                  ]
                })
          };
  }
  var child = data[idx];
  switch (child.TAG | 0) {
    case /* BitmapIndexed */1 :
        var trie = child._0;
        var newChild = bitmapIndexed_assocInternal(trie, shift + 5 | 0, hasher, hash, key, value);
        if (newChild === trie) {
          return self;
        } else {
          return {
                  bitmap: bitmap,
                  data: JsArray.cloneAndSet(data, idx, {
                        TAG: /* BitmapIndexed */1,
                        _0: newChild
                      })
                };
        }
    case /* ArrayMap */0 :
    case /* HashArrayMap */2 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Hamt.res",
                339,
                11
              ],
              Error: new Error()
            };
    case /* MapEntry */3 :
        var match$1 = child._0;
        var v = match$1[1];
        var k = match$1[0];
        if (Caml_obj.caml_equal(k, key)) {
          if (Caml_obj.caml_equal(v, value)) {
            return self;
          } else {
            return {
                    bitmap: bitmap,
                    data: JsArray.cloneAndSet(data, idx, {
                          TAG: /* MapEntry */3,
                          _0: [
                            key,
                            value
                          ]
                        })
                  };
          }
        }
        var leaf = makeNode(shift + 5 | 0, hasher, hasher(k), k, v, hash, key, value);
        return {
                bitmap: bitmap,
                data: JsArray.cloneAndSet(data, idx, leaf)
              };
    case /* HashCollision */4 :
        var node = child._0;
        if (node.hash === hash) {
          var newChild$1 = assoc(node, key, value);
          if (newChild$1 === node) {
            return self;
          } else {
            return {
                    bitmap: bitmap,
                    data: JsArray.cloneAndSet(data, idx, {
                          TAG: /* HashCollision */4,
                          _0: newChild$1
                        })
                  };
          }
        }
        var newChild$2 = bitmapIndexed_assocInternal({
              bitmap: bitpos(node.hash, shift + 5 | 0),
              data: [{
                  TAG: /* HashCollision */4,
                  _0: node
                }]
            }, shift + 5 | 0, hasher, hash, key, value);
        return {
                bitmap: bitmap,
                data: JsArray.cloneAndSet(data, idx, {
                      TAG: /* BitmapIndexed */1,
                      _0: newChild$2
                    })
              };
    
  }
}

function makeNode(shift, hasher, h1, k1, v1, h2, k2, v2) {
  if (h1 === h2) {
    return {
            TAG: /* HashCollision */4,
            _0: {
              hash: h1,
              entries: [
                [
                  k1,
                  v1
                ],
                [
                  k2,
                  v2
                ]
              ]
            }
          };
  } else {
    return {
            TAG: /* BitmapIndexed */1,
            _0: bitmapIndexed_assocInternal(bitmapIndexed_assocInternal({
                      bitmap: 0,
                      data: []
                    }, shift, hasher, h1, k1, v1), shift, hasher, h2, k2, v2)
          };
  }
}

function bitmapIndexed_dissoc(self, shift, hash, key) {
  var data = self.data;
  var bitmap = self.bitmap;
  var bit = bitpos(hash, shift);
  var match = bitmap & bit;
  if (match === 0) {
    return self;
  }
  var idx = indexOfBit(bitmap, bit);
  var child = data[idx];
  switch (child.TAG | 0) {
    case /* BitmapIndexed */1 :
        var trie = child._0;
        var newChild = bitmapIndexed_dissoc(trie, shift + 5 | 0, hash, key);
        if (newChild !== undefined) {
          if (newChild === trie) {
            return self;
          } else {
            return {
                    bitmap: bitmap,
                    data: JsArray.cloneAndSet(data, idx, {
                          TAG: /* BitmapIndexed */1,
                          _0: newChild
                        })
                  };
          }
        } else {
          return unset(self, bit, idx);
        }
    case /* ArrayMap */0 :
    case /* HashArrayMap */2 :
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Hamt.res",
                411,
                11
              ],
              Error: new Error()
            };
    case /* MapEntry */3 :
        if (Caml_obj.caml_equal(child._0[0], key)) {
          return unset(self, bit, idx);
        } else {
          return self;
        }
    case /* HashCollision */4 :
        var node = child._0;
        var newChild$1 = dissoc(node, key);
        if (newChild$1 !== undefined) {
          if (newChild$1 === node) {
            return self;
          } else {
            return {
                    bitmap: bitmap,
                    data: JsArray.cloneAndSet(data, idx, {
                          TAG: /* HashCollision */4,
                          _0: newChild$1
                        })
                  };
          }
        } else {
          return unset(self, bit, idx);
        }
    
  }
}

function unset(param, bit, idx) {
  var bitmap = param.bitmap;
  if (bitmap === bit) {
    return ;
  } else {
    return {
            bitmap: bitmap ^ bit,
            data: JsArray.cloneWithout(param.data, idx)
          };
  }
}

function assoc$1(node, shift, hasher, hash, key, value) {
  switch (node.TAG | 0) {
    case /* ArrayMap */0 :
        var entries = node._0;
        var idx = arrayMap_findIndex(entries, key);
        if (idx === -1 && entries.length >= 8) {
          var newNode_bitmap = bitpos(hasher(key), shift);
          var newNode_data = [{
              TAG: /* MapEntry */3,
              _0: [
                key,
                value
              ]
            }];
          var newNode = {
            bitmap: newNode_bitmap,
            data: newNode_data
          };
          return bitmapIndexed_fromArrayMap(newNode, entries, shift, hasher);
        }
        var newEntries = arrayMap_assocAt(entries, idx, key, value);
        if (newEntries === entries) {
          return ;
        } else {
          return {
                  TAG: /* ArrayMap */0,
                  _0: newEntries
                };
        }
    case /* BitmapIndexed */1 :
        var param = node._0;
        var data = param.data;
        var bitmap = param.bitmap;
        var bit = bitpos(hash, shift);
        var idx$1 = indexOfBit(bitmap, bit);
        var match = bitmap & bit;
        if (match === 0) {
          return {
                  TAG: /* BitmapIndexed */1,
                  _0: {
                    bitmap: bitmap | bit,
                    data: JsArray.cloneAndInsert(data, idx$1, {
                          TAG: /* MapEntry */3,
                          _0: [
                            key,
                            value
                          ]
                        })
                  }
                };
        }
        var child = data[idx$1];
        var node$1 = assoc$1(child, shift + 5 | 0, hasher, hash, key, value);
        if (node$1 !== undefined) {
          return {
                  TAG: /* BitmapIndexed */1,
                  _0: {
                    bitmap: bitmap,
                    data: JsArray.cloneAndSet(data, idx$1, node$1)
                  }
                };
        } else {
          return ;
        }
    case /* HashArrayMap */2 :
        var param$1 = node._0;
        var nodes = param$1.nodes;
        var idx$2 = mask(hash, shift);
        var node$2 = nodes[idx$2];
        if (node$2 !== undefined) {
          return assoc$1(node$2, shift + 5 | 0, hasher, hash, key, value);
        } else {
          return {
                  TAG: /* HashArrayMap */2,
                  _0: {
                    count: param$1.count + 1 | 0,
                    nodes: JsArray.cloneAndSet(nodes, idx$2, {
                          TAG: /* MapEntry */3,
                          _0: [
                            key,
                            value
                          ]
                        })
                  }
                };
        }
    case /* MapEntry */3 :
        var param$2 = node._0;
        var v = param$2[1];
        var k = param$2[0];
        if (Caml_obj.caml_equal(k, key)) {
          if (Caml_obj.caml_equal(v, value)) {
            return ;
          } else {
            return {
                    TAG: /* MapEntry */3,
                    _0: [
                      key,
                      value
                    ]
                  };
          }
        } else {
          return makeNode(shift + 5 | 0, hasher, hasher(k), k, v, hash, key, value);
        }
    case /* HashCollision */4 :
        var self = node._0;
        var match$1 = hashCollision_findIndex(self, key);
        if (match$1 !== -1) {
          return ;
        } else {
          return {
                  TAG: /* HashCollision */4,
                  _0: {
                    hash: self.hash,
                    entries: JsArray.cloneAndAdd(self.entries, [
                          key,
                          value
                        ])
                  }
                };
        }
    
  }
}

function bitmapIndexed_fromArrayMap(node, entries, shift, hasher) {
  var node$1 = node;
  for(var i = 0 ,i_finish = entries.length; i < i_finish; ++i){
    var match = entries[i];
    var k = match[0];
    node$1 = bitmapIndexed_assocInternal(node$1, shift, hasher, hasher(k), k, match[1]);
  }
  return {
          TAG: /* BitmapIndexed */1,
          _0: node$1
        };
}

function dissoc$1(node, shift, hash, key) {
  switch (node.TAG | 0) {
    case /* ArrayMap */0 :
        var node$1 = node._0;
        var newNode = arrayMap_dissoc(node$1, key);
        if (newNode === node$1) {
          return ;
        } else {
          return {
                  TAG: /* ArrayMap */0,
                  _0: newNode
                };
        }
    case /* BitmapIndexed */1 :
        var node$2 = node._0;
        var newNode$1 = bitmapIndexed_dissoc(node$2, shift, hash, key);
        if (newNode$1 !== undefined) {
          if (newNode$1 === node$2) {
            return ;
          } else {
            return {
                    TAG: /* BitmapIndexed */1,
                    _0: newNode$1
                  };
          }
        } else {
          return {
                  TAG: /* ArrayMap */0,
                  _0: []
                };
        }
    default:
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "Hamt.res",
              585,
              4
            ],
            Error: new Error()
          };
  }
}

function log(node) {
  switch (node.TAG | 0) {
    case /* ArrayMap */0 :
        console.log("ArrayNode: " + node._0);
        return ;
    case /* BitmapIndexed */1 :
        console.log("BitmapIndexed: " + Bit.toBinString(node._0.bitmap));
        return ;
    default:
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "Hamt.res",
              593,
              9
            ],
            Error: new Error()
          };
  }
}

export {
  empty ,
  find ,
  assoc$1 as assoc,
  dissoc$1 as dissoc,
  log ,
  
}
/* No side effect */
