// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Bit from "./Bit.js";
import * as JsArray from "./JsArray.js";
import * as Caml_obj from "@rescript/std/lib/es6/caml_obj.js";
import * as Belt_Array from "@rescript/std/lib/es6/belt_Array.js";
import * as Belt_Option from "@rescript/std/lib/es6/belt_Option.js";
import * as Caml_option from "@rescript/std/lib/es6/caml_option.js";

function empty(param) {
  return {
          TAG: /* ArrayMap */0,
          _0: []
        };
}

function hashCollision_findIndex(param, key) {
  return param.entries.findIndex(function (param) {
              return Caml_obj.caml_equal(param[0], key);
            });
}

function arrayMap_findIndex(entries, key) {
  var len = entries.length;
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= len) {
      return -1;
    }
    if (Caml_obj.caml_equal(entries[i][0], key)) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function arrayMap_assocAt(entries, idx, key, value) {
  if (idx !== -1) {
    if (entries[idx][1] === value) {
      return entries;
    } else {
      return JsArray.cloneAndSet(entries, idx, [
                  key,
                  value
                ]);
    }
  } else {
    return JsArray.cloneAndAdd(entries, [
                key,
                value
              ]);
  }
}

function arrayMap_dissoc(entries, key) {
  var idx = arrayMap_findIndex(entries, key);
  if (idx === -1) {
    return entries;
  } else {
    return JsArray.cloneWithoutUnstable(entries, idx);
  }
}

function mask(hash, shift) {
  return (hash >>> shift) & 31;
}

function bitpos(hash, shift) {
  return (1 << mask(hash, shift));
}

function indexOfBit(bitmap, bit) {
  var v = bitmap & (bit - 1 | 0);
  var v$1 = v - ((v >>> 1) & 1431655765) | 0;
  var v$2 = (v$1 & 858993459) + ((v$1 >>> 2) & 858993459) | 0;
  var v$3 = v$2 + (v$2 >>> 4) & 252645135;
  var v$4 = v$3 + (v$3 >>> 8) | 0;
  var v$5 = v$4 + (v$4 >>> 16) | 0;
  return v$5 & 127;
}

function bitmapIndexed_make(shift, hash, key, value) {
  return {
          bitmap: bitpos(hash, shift),
          data: [{
              TAG: /* MapEntry */3,
              _0: [
                key,
                value
              ]
            }]
        };
}

function bitmapIndexed_findIndex(param, bit) {
  var bitmap = param.bitmap;
  var match = bitmap & bit;
  if (match !== 0) {
    return indexOfBit(bitmap, bit);
  } else {
    return -1;
  }
}

function find(node, shift, hash, key) {
  switch (node.TAG | 0) {
    case /* ArrayMap */0 :
        var entries = node._0;
        var idx = arrayMap_findIndex(entries, key);
        if (idx === -1) {
          return ;
        } else {
          return Caml_option.some(entries[idx][1]);
        }
    case /* BitmapIndexed */1 :
        var param = node._0;
        var bitmap = param.bitmap;
        var bit = bitpos(hash, shift);
        var match = bitmap & bit;
        if (match === 0) {
          return ;
        }
        var idx$1 = indexOfBit(bitmap, bit);
        var child = param.data[idx$1];
        return find(child, shift, hash, key);
    case /* HashArrayMap */2 :
        var param$1 = node._0;
        var idx$2 = mask(hash, shift);
        var node$1 = param$1.nodes[idx$2];
        if (node$1 !== undefined) {
          return find(node$1, shift, hash, key);
        } else {
          return ;
        }
    case /* MapEntry */3 :
        var match$1 = node._0;
        if (Caml_obj.caml_equal(match$1[0], key)) {
          return Caml_option.some(match$1[1]);
        } else {
          return ;
        }
    case /* HashCollision */4 :
        var param$2 = node._0;
        var match$2 = param$2.entries.find(function (param) {
              return Caml_obj.caml_equal(param[0], key);
            });
        if (match$2 !== undefined) {
          return Caml_option.some(match$2[1]);
        } else {
          return ;
        }
    
  }
}

function unpack(_bitmap, packed, _i, unpacked, _j) {
  while(true) {
    var j = _j;
    var i = _i;
    var bitmap = _bitmap;
    if (bitmap === 0) {
      return i;
    }
    if ((bitmap & 1) === 1) {
      unpacked[j] = Caml_option.some(packed[i]);
      _j = j + 1 | 0;
      _i = i + 1 | 0;
      _bitmap = (bitmap >>> 1);
      continue ;
    }
    _j = j + 1 | 0;
    _bitmap = (bitmap >>> 1);
    continue ;
  };
}

function hashArrayMap_fromBitmapIndexed(param, shift, hash, key, value) {
  var unpacked = Array(32);
  var count = unpack(param.bitmap, param.data, 0, unpacked, 0);
  var idx = mask(hash, shift);
  unpacked[idx] = {
    TAG: /* MapEntry */3,
    _0: [
      key,
      value
    ]
  };
  return {
          TAG: /* HashArrayMap */2,
          _0: {
            count: count + 1 | 0,
            nodes: unpacked
          }
        };
}

function assoc(node, shift, hasher, hash, key, value) {
  switch (node.TAG | 0) {
    case /* ArrayMap */0 :
        var entries = node._0;
        var idx = arrayMap_findIndex(entries, key);
        if (idx === -1 && entries.length >= 8) {
          var newNode = bitmapIndexed_make(shift, hasher(key), key, value);
          return bitmapIndexed_fromArrayMap(newNode, entries, shift, hasher);
        }
        var newEntries = arrayMap_assocAt(entries, idx, key, value);
        if (newEntries === entries) {
          return ;
        } else {
          return {
                  TAG: /* ArrayMap */0,
                  _0: newEntries
                };
        }
    case /* BitmapIndexed */1 :
        var node$1 = node._0;
        var bit = bitpos(hash, shift);
        var idx$1 = bitmapIndexed_findIndex(node$1, bit);
        if (idx$1 === -1 && node$1.data.length >= 16) {
          return hashArrayMap_fromBitmapIndexed(node$1, shift, hash, key, value);
        } else {
          return bitmapIndexed_assoc(node$1, shift, hasher, hash, key, value);
        }
    case /* HashArrayMap */2 :
        var param = node._0;
        var nodes = param.nodes;
        var count = param.count;
        var idx$2 = mask(hash, shift);
        var node$2 = nodes[idx$2];
        if (node$2 === undefined) {
          return {
                  TAG: /* HashArrayMap */2,
                  _0: {
                    count: count + 1 | 0,
                    nodes: JsArray.cloneAndSet(nodes, idx$2, {
                          TAG: /* MapEntry */3,
                          _0: [
                            key,
                            value
                          ]
                        })
                  }
                };
        }
        var newNode$1 = assoc(node$2, shift + 5 | 0, hasher, hash, key, value);
        if (newNode$1 !== undefined) {
          return {
                  TAG: /* HashArrayMap */2,
                  _0: {
                    count: count,
                    nodes: JsArray.cloneAndSet(nodes, idx$2, newNode$1)
                  }
                };
        } else {
          return ;
        }
    case /* MapEntry */3 :
        var param$1 = node._0;
        var v = param$1[1];
        var k = param$1[0];
        if (Caml_obj.caml_equal(k, key)) {
          if (Caml_obj.caml_equal(v, value)) {
            return ;
          } else {
            return {
                    TAG: /* MapEntry */3,
                    _0: [
                      key,
                      value
                    ]
                  };
          }
        }
        var h1 = hasher(k);
        if (h1 === hash) {
          return {
                  TAG: /* HashCollision */4,
                  _0: {
                    hash: h1,
                    entries: [
                      [
                        k,
                        v
                      ],
                      [
                        key,
                        value
                      ]
                    ]
                  }
                };
        }
        var node$3 = bitmapIndexed_make(shift, h1, k, v);
        return bitmapIndexed_assoc(node$3, shift, hasher, hash, key, value);
    case /* HashCollision */4 :
        var self = node._0;
        var match = hashCollision_findIndex(self, key);
        if (match !== -1) {
          return ;
        } else {
          return {
                  TAG: /* HashCollision */4,
                  _0: {
                    hash: self.hash,
                    entries: JsArray.cloneAndAdd(self.entries, [
                          key,
                          value
                        ])
                  }
                };
        }
    
  }
}

function bitmapIndexed_assoc(param, shift, hasher, hash, key, value) {
  var data = param.data;
  var bitmap = param.bitmap;
  var bit = bitpos(hash, shift);
  var idx = indexOfBit(bitmap, bit);
  var match = bitmap & bit;
  if (match === 0) {
    return {
            TAG: /* BitmapIndexed */1,
            _0: {
              bitmap: bitmap | bit,
              data: JsArray.cloneAndInsert(data, idx, {
                    TAG: /* MapEntry */3,
                    _0: [
                      key,
                      value
                    ]
                  })
            }
          };
  }
  var child = data[idx];
  var node = assoc(child, shift + 5 | 0, hasher, hash, key, value);
  if (node !== undefined) {
    return {
            TAG: /* BitmapIndexed */1,
            _0: {
              bitmap: bitmap,
              data: JsArray.cloneAndSet(data, idx, node)
            }
          };
  }
  
}

function bitmapIndexed_fromArrayMap(node, entries, shift, hasher) {
  var node$1 = {
    TAG: /* BitmapIndexed */1,
    _0: node
  };
  for(var i = 0 ,i_finish = entries.length; i < i_finish; ++i){
    var match = entries[i];
    var k = match[0];
    node$1 = Belt_Option.getExn(assoc(node$1, shift, hasher, hasher(k), k, match[1]));
  }
  return node$1;
}

function dissoc(node, shift, hash, key) {
  switch (node.TAG | 0) {
    case /* ArrayMap */0 :
        var node$1 = node._0;
        var newNode = arrayMap_dissoc(node$1, key);
        if (newNode === node$1) {
          return ;
        } else {
          return /* Node */{
                  _0: {
                    TAG: /* ArrayMap */0,
                    _0: newNode
                  }
                };
        }
    case /* BitmapIndexed */1 :
        var param = node._0;
        var data = param.data;
        var bitmap = param.bitmap;
        var bit = bitpos(hash, shift);
        var match = bitmap & bit;
        if (match === 0) {
          return ;
        }
        var idx = indexOfBit(bitmap, bit);
        var child = data[idx];
        var match$1 = dissoc(child, shift + 5 | 0, hash, key);
        if (match$1 !== undefined) {
          if (match$1) {
            return /* Node */{
                    _0: {
                      TAG: /* BitmapIndexed */1,
                      _0: {
                        bitmap: bitmap,
                        data: JsArray.cloneAndSet(data, idx, match$1._0)
                      }
                    }
                  };
          } else if (bitmap === bit) {
            return /* Empty */0;
          } else {
            return /* Node */{
                    _0: {
                      TAG: /* BitmapIndexed */1,
                      _0: {
                        bitmap: bitmap ^ bit,
                        data: JsArray.cloneWithout(data, idx)
                      }
                    }
                  };
          }
        } else {
          return ;
        }
    case /* HashArrayMap */2 :
        var param$1 = node._0;
        var nodes = param$1.nodes;
        var count = param$1.count;
        var idx$1 = mask(hash, shift);
        var child$1 = nodes[idx$1];
        if (child$1 === undefined) {
          return ;
        }
        var match$2 = dissoc(child$1, shift + 5 | 0, hash, key);
        if (match$2 !== undefined) {
          if (match$2) {
            return /* Node */{
                    _0: {
                      TAG: /* HashArrayMap */2,
                      _0: {
                        count: count,
                        nodes: JsArray.cloneAndSet(nodes, idx$1, match$2._0)
                      }
                    }
                  };
          } else if (count === 1) {
            return /* Empty */0;
          } else {
            return /* Node */{
                    _0: {
                      TAG: /* HashArrayMap */2,
                      _0: {
                        count: count - 1 | 0,
                        nodes: JsArray.cloneAndSet(nodes, idx$1, undefined)
                      }
                    }
                  };
          }
        } else {
          return ;
        }
    case /* MapEntry */3 :
        var k = node._0[0];
        if (!Caml_obj.caml_equal(k, key)) {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "Hamt.res",
                  392,
                  4
                ],
                Error: new Error()
              };
        }
        if (Caml_obj.caml_equal(k, key)) {
          return /* Empty */0;
        } else {
          return ;
        }
    case /* HashCollision */4 :
        var self = node._0;
        var entries = self.entries;
        var idx$2 = hashCollision_findIndex(self, key);
        if (idx$2 === -1) {
          return ;
        } else if (entries.length === 1) {
          return /* Empty */0;
        } else {
          return /* Node */{
                  _0: {
                    TAG: /* HashCollision */4,
                    _0: {
                      hash: self.hash,
                      entries: JsArray.cloneWithout(entries, idx$2)
                    }
                  }
                };
        }
    
  }
}

function log(node) {
  var f = function (node, depth) {
    var ilog = function (string) {
      console.log("  ".repeat(depth) + string);
      
    };
    switch (node.TAG | 0) {
      case /* ArrayMap */0 :
          return ilog("ArrayNode: " + node._0);
      case /* BitmapIndexed */1 :
          var match = node._0;
          ilog("BitmapIndexed: " + Bit.toBinString(match.bitmap));
          match.data.forEach(function (child) {
                return f(child, depth + 1 | 0);
              });
          return ;
      case /* HashArrayMap */2 :
          var match$1 = node._0;
          ilog("HashArrayMap: " + match$1.count);
          return Belt_Array.forEachWithIndex(match$1.nodes, (function (i, n) {
                        if (n !== undefined) {
                          return f(n, depth + 1 | 0);
                        } else {
                          return ilog("  (undefined): " + i);
                        }
                      }));
      case /* MapEntry */3 :
          return ilog("MapEntry: " + node._0[0]);
      case /* HashCollision */4 :
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "Hamt.res",
                  499,
                  11
                ],
                Error: new Error()
              };
      
    }
  };
  return f(node, 0);
}

export {
  empty ,
  find ,
  assoc ,
  dissoc ,
  log ,
  
}
/* No side effect */
